모의 SW 역량테스트 문제풀이 방법입니다.
---

## 1767 - 프로세서 연결하기

22.09.23 풀이

N x N 크기의 회로판에 프로세서의 위치가 주어지고, 최대한 많은 프로세서를 경계선 바깥과 연결하면서 최소한의 전선을 사용하려고 한다. 이 때 사용된 전선의 길이를 출력하는 문제

프로세서의 위치를 입력받으면서 경계선과 붙어있지 않는 프로세서의 위치를 list에 저장한다.

가장 많은 수부터 list에서 연결할 프로세서의 위치를 조합으로 뽑으면서 가능한 상황이 있는지 판단한다.

프로세서를 연결하는 것도 재귀함수를 통해 구현하였는데, 델타 이동을 이용하여 네방향으로 뻗어나가다가 경계선을 만나지 못하면 다시 돌아오도록 하였다.

## 1949 - 등산로 조성

22.10.12 풀이

가장 높은 봉우리로 부터, 점차 내려가는 등산로를 만들려고 할 때, 한 번만 K만큼까지 산을 깎을 수 있다. 등산로의 가능한 최대 길이를 찾는 문제

dfs를 통해 풀이하였다.

가장 높은 봉우리의 위치를 기억해두고, 각 봉우리에서 dfs를 통해 점차 낮은 봉우리를 찾아나갔다.

한번 K보다 적게 차이나는 봉우리로 산을 깎을 수 있었고, 해당 위치를 깎을 경우, 다시 dfs가 복귀하였을 때, 해당 위치를 원상 복구 시켜주는 것이 주요했다.

## 2105 - 디저트 카페

22.09.27 풀이

격자지도에 디저트 카페가 나열되어 있고, 각 디저트 카페에 번호가 쓰여져 있다. 대각선으로 이동하면서 최종 모양이 사각형을 이루고, 동일한 번호를 가진 디저트 카페를 들리지 않는다고 할 때, 방문이 가능한 최대의 카페수를 구하는 문제

사각형을 이루어야하기 때문에 방향전환은 좌하, 우하, 우상, 좌상 순서로 현재 진행방향 혹은 90도 전환한 방향만이 가능하다.

지금까지 지나온 카페들의 번호를 저장하기 위하여 List를 통해 저장했고, List에 가지고 있는 카페를 만나면 return하도록 재귀함수를 구성하였다.

현재 진행방향이 좌상 방향이라면, 현재 진행방향만을 유지하며 이동하도록 하였고,

재귀함수 마지막에는 현재 방문한 카페의 숫자를 지우는 코드를 잊지 말아야한다.

## 2112 - 보호 필름

22.09.23 풀이

보호 필름을 제작할 때, 각 칸이 A 또는 B로 이루어져 있다고 한다면 새로로 연속된 칸이 K칸 이상 있어야 통과할 수 있다. 가로로 한 줄을 A 또는 B로 바꿀 수 있다고 할 때, 가장 적은 횟수로 통과하려면 몇 번 바꾸어야 통과할 수 있는 지 출력하는 문제

현재 상태가 통과할 수 있는 상태인지 판단하는 메소드와 세로 한줄이 통과하는 지 판단하는 메소드를 만들었다.

D줄 중에서 0부터 D까지를 뽑아서 A 또는 B로 바꾸어가며 통과하는 상태인지 확인하는 것으로 풀이하였다.

일단, D줄 중에서 r줄을 뽑는 조합을 작성하였고, r줄을 뽑았다면 그 r줄을 각각 A 또는 B로 바꾸는 재귀함수를 작성하였다.

A 또는 B를 적용할 시에, 원본 배열을 바꿔버린다면, 다시 되돌리기 어려우므로, 검사시에는 임시로 한 열을 만들어 배열에서 바꾸고 검사하는 방식을 채택하였다.

모든 열에 대해 통과했다면, flag를 true로 만들고, 각 재귀함수가 호출 되기전에 flag가 true라면 호출하지 않고 return한다는 코드를 넣어줘야한다. 

## 2383 - 점심 식사시간

22.09.29 풀이

좌표에 사람의 위치와 계단의 위치가 주어지고, 계단의 길이가 주어진다. 사람은 한칸을 이동할 때, 시간 1이 소요되고 계단을 내려가기 이전에는 1만큼 기다려야하고 계단은 동시에 3명까지만 이용할 수 있다고 할 때, 모두 아래층으로 내려가는 데 걸리는 최단 시간을 구하는 문제

좌표를 입력받으면서 사람의 좌표를 저장하는 Person클래스와 계단의 좌표와 길이를 저장하는 Stair클래스를 만들어 저장하였다.

Person 클래스에는 각 계단 까지의 거리를 저장하는 배열이 존재하고, Stair 클래스에는 그 계단으로 가는 사람들의 List도 존재한다.

dfs를 통해서 각 사람들이 둘 중 어느 계단으로 가는 지 모든 경우의 수를 고려할 수 있도록 했다.

각 사람이 어느 계단으로 갈 지 결정이 된 후에는, 두 계단에서 각각 사람들이 모두 내려가는 데까지 걸리는 시간을 계산하였다.

3명까지는 순서가 상관없지만, 거리가 가까운 순서대로 정렬을 하였다.

3명까지는 계단까지의 거리 + 기다리는 시간 1 + 계단의 길이를 그대로 사용하면 되지만, 동시에 4명 이상이 계단을 이용할 수 없으므로, 

4명 이상부터는 자신보다 3명 앞에 온 사람이 계단을 빠져나가는 시간과 자신이 도착한 시간 + 1을 비교하여 더 큰 값에 계단의 길이를 더하여 구하는 방식으로 계산하였다.

위 방식으로 모든 사람을 계산한 뒤에 마지막 사람이 빠져나가는 시간이 곧 그 계단을 모두 빠져나가는 시간이다.

두 계단 중 더 오래 걸리는 시간이 해당 경우의 수의 시간이고, 모든 경우의 수 중에서 가장 짧은 시간을 출력하는 것으로 풀이하였다.  

## 4008 - 숫자 만들기

22.09.22 풀이

고정된 숫자들 사이에 연산자들을 넣어 결과를 얻는다고 할 때, 가능한 결과의 최대값과 최소값의 차이를 출력하는 문제

연산자들의 갯수를 입력받아, 중복을 고려하지 않고 시행할 경우, 시간 초과가 발생한다.

따라서 중복이 발생하지 않는 방식으로 진행하여야 한다.

각 연산자들의 수가 주어졌기 때문에 연산자들을 하나씩 뽑을 때마다, 해당 연산자를 주어진 수 보다 적게 쓰고 있는지 확인하면서 뽑아야한다.

그래야 중복을 제거한 순열을 만들어 사용할 수 있다.

비슷한 방식으로 연산자들을 하나씩 뽑을 때마다, 주어진 연산자의 갯수 배열에서 하나씩 줄여나가도 된다.

## 4012 - 요리사

22.09.20 풀이

짝수개로 주어지는 음식 재료들을 둘로 나누어, 각 재료들의 시너지를 더해 두 음식 사이의 최소한의 시너지값 차이를 구하는 문제

음식 재료들을 둘로 나누는 조합과 각 재료들에서 각각 2개씩 나누는 조합, 총 두번의 조합을 진행하여야한다.

조합을 통해 뽑은 음식 재료들을 List에 담아, 두 번째 조합에 이용하였다.

## 5656 - 벽돌 깨기

22.09.29 풀이

각 열의 가장 위의 벽돌을 깰 수 있다고 할 때, 해당 수의 적 힌 범위대로 상하좌우 벽돌을 연속적으로 터뜨린다. N개의 벽돌을 깬다고 할 때, 가장 적게 남은 벽돌의 수를 구하는 문제

1. W개의 열 중에서  N개를 중복을 허용하여 순열을 만든다.
2. 순열 순서대로 터트려본다.
3. 가장 적게 남은 경우가 답이다.

위 방식대로 풀이하였다.

W개의 열 중에서 N개 중복 순열로 만들고 터뜨려 본다. 경우의 수 : 0000 ~ W-1,W-1,W-1,W-1

원본 배열에서 터트리는 것을 구현하는 경우, 다시 복구하는 것이 어렵기 때문에 순열 하나마다 새롭게 배열을 복사해주어 사용하였다.

해당 벽돌을 폭파하는 과정은 bfs를 통해 범위내에 있는 벽돌을 폭파시키는 것을 구현하였다.

한번의 폭발이 일어날 때마다 빈칸이 있으면 아래로 내려주는 메소드로 만들어 사용하였다. 