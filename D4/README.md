D4 문제풀이 방법입니다.

## 1210

22.08.11 풀이

100 x 100 크기의 2차원 배열의 형태로, 0바탕에 1로 그려진 사다리게임이 존재한다. 아래 도착지점 중 하나에 2로 표시되어 있다고 할 때, 그 2에 도착하는 시작지점의 x좌표를 출력하는 문제

시작지점인 2를 기준으로, 거슬러 올라가는 방법으로 풀이하였다.

좌상우하 방향으로 델타이동 배열을 만들고, 0행에 도달할 때까지 한칸씩 전진하며, 네가지 조건으로 방향을 결정해 주었다.

1. 좌우가 모두 0 인 경우, 현재 진행방향으로 전진
2. 왼쪽만 1인 경우, 좌회전
3. 오른쪽만 1인 경우, 우회전
4. 양쪽 모두 1인 경우, 위쪽으로 올라간다.

이와같이 네가지 경우로 나누어 델타이동 배열의 인덱스를 바꿔줌으로써 목표지점에 도착하도록 하였다.

> 또 다른 풀이

델타이동을 사용하지 않고 풀이하는 방법

- 매 칸마다 좌우만 살피고, 좌우가 있는 쪽으로 0이 나올때까지 인덱스를 줄인다. 그렇지 않은 경우엔, 행을 거슬러 올라간다.

## 1218

22.08.19 풀이

({[< 네 가지 종류의 괄호로만 이루어진 문자열이 주어지고,해당 문자열의 괄호들이 알맞게 열리고 닫혔는 지 판별하는 문제. 

해당 문자열을 `text.split("")`메소드를 통해 한 글자씩 배열로 저장하고,

여는 괄호 문자열 "){[<" 과 닫는 괄호 문자열 ")}]>" 을 각각 선언하였다.

괄호 배열에서 하나씩 읽으면서 여는 문자열일 경우, stack에 push하고 닫는 문자열일 경우, `stack.peek()`와 비교하여 짝을 이룰 경우에만 pop()을 하고 아닌 경우, break로 반복문을 빠져 나왔다.

반복문이 끝난 후, stack이 비어있다면 1을 출력하고 stack에 값이 남아있다면 0을 출력하였다.

## 1222

22.08.18 풀이

문자열로 주어진 식을 후위표시로 바꾸어 계산하는 문제

이 문제에서는 + 만 존재하기 때문에 가장 첫 자리를 제외하고 두자리씩 자리만 바꿔주면 후위표시로 변경이 가능하다.

위와 같은 방식으로 `StringBuilder`를 이용하여 후위표시식으로 바꾸어, 한글자 씩 stack에 넣고 연산자를 만나면 두개의 수를 `pop()`하여 연산하고 다시 `push()`하는 방식으로 계산하였다.

## 1223

22.08.18 풀이

위 계산기 문제에 + 와 더불어 * 도 나오는 문자열을 받아 후위초기식으로 바꾸어 계산하는 문제

풀이 방식 자체는 위 문제와 동일하지만, 연산자를 stack에 저장하는 과정에서 우선순위를 비교해줘야 한다.

+가 나오면 동일 우선순위까지 모두 pop()을 해줘야하기에 stack이 비워질 때까지 pop()을 해줘야한다.

*이 나오면 +가 맨위에 위치할 때까지 pop()을 해줘야한다.

후위표현식 계산방식은 동일하다.

## 1224

22.08.18 풀이

문자열 계산의 마지막 문제. 사칙연산과 더불어 괄호까지 존재하는 문자열 식을 받아 후위표기법으로 변환하고 계산하여 출력하는 문제.

후위표기법으로 변환하는 과정에서 사칙연산의 우선순위를 배정해주었다. 이 과정에서 Map을 사용하였다.

(는 0, +,-는 1, *,/는 2로 Map에 저장하고 stack에 한글자씩 넣으면서 현 stack.peek()와 비교하여 우선순위가 높은 경우에만 push하고 낮다면 높을때까지 pop()한 후에 push하였다.

(는 우선순위는 가장 낮지만, stack에 넣을 때는 무조건 push()한다.

)가 나오면 stack.peek()에 (가 나올 때까지 pop()하고 (는 버린다.

위와 같은 방식으로 후위표현식으로 바꾼 뒤 동일한 방식으로 계산하여 출력하였다.

## 1231

22.08.23 풀이

완전 이진 트리의 순서대로 해당 숫자와 해당 칸의 알파벳, 그리고 자식 노드의 번호가 차례대로 주어진다. 이 완전 이진트리를 중위 순회로 돌아 알파벳을 순서대로 출력하는 문제

완전 이진 트리를 배열로 구현하였을 때와 같이 인덱스가 주어지기 때문에 트리를 구현할 필요는 없다.

노드의 수 만큼의 배열을 만들어 해당 인덱스에 맞게 배열에 저장하고, 중위순회 순서대로 출력해주기만 하면된다.

중위 순회를 구현하는 방식은 재귀함수를 통해 구현하였다. 왼쪽 자식 > 본인 > 오른쪽 자식 순서로 출력해주면 된다.

재귀함수는 null을 만나면 중지하는 방식으로 구현하였다.

## 2819 - 격자판의 숫자 이어 붙이기

22.08.25 풀이

4 x 4 배열에 0부터 9의 숫자가 임의로 들어가 있다. 임의의 위치에서 시작하여 상하좌우 임의의 방향으로 6번 움직여, 지나간 7자리 숫자를 만든다고 할 때, 만들 수 있는 수의 종류를 구해 출력하는 문제

델타이동과 재귀함수를 이용하여 풀이하였다.

각 칸에서 상하좌우로 이동하면서 현재 칸의 숫자를 문자열에 이어붙이는 방식으로 하였다. 

상하좌우로 이동하여 또 상하좌우로 이동해야했기에 모든 경우의 수를 보려면 재귀함수를 이용해야했다. 

재귀함수를 이용하면서 문자열의 길이가 7이 되면 해당 문자열을 set에 넣었다.

이 때, set을 이용한 이유는 중복되는 것을 제거해주기 위함이었다.

## 5432

22.08.16 풀이

괄호를 통해 쇠막대기의 위치가 표시된다. 단, ()처럼 붙어있는 경우는 쇠막대기가 아니라 레이저이다. 이 레이저가 다른 쇠막대기를 자른다고 할 때, 잘린 쇠막대기의 수를 구하는 문제.

바로, stack을 통해 입력받으면서 판단하기엔 레이저와 쇠막대기를 구분하기 어렵기 때문에, `replace()`메소드를 이용하여 ()를 L로 바꿔주었다.

그리고 한 글자씩 읽으며 계산을 하였다.

(이 나올 경우, stack에 push하였고, L이 나올 경우, 현재 stack에 있는 ( 갯수를 최종 쇠막대기 갯수에 더해주고, )이 나올 경우, stack에서 (를 하나 빼주고, 최종 쇠막대기 갯수에 1을 더해주었다.