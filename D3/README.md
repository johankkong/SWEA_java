D3 문제풀이 방법입니다.

## 1860

22.07.18 풀이

M초 마다 K개의 붕어빵을 생산한다고 할때 N명의 사람이 도착하는 시간을 입력받아 N명의 사람이 기다리는 시간없이 붕어빵을 가져갈 수 있는지 출력하는 문제

N명의 사람이 도착하는 시간이 순서대로 주어져 있지 않아, 배열로 입력받은 뒤 `Arrays.sort(arr);`을 이용하여 정렬하였다.

그리고 순차적으로 각 도착하는 시간을 M으로 나누고 K를 곱하여 현재까지 생산된 붕어빵의 갯수를 구하였다.

그리고 지금까지 다녀간 사람들의 명수를 빼는 것을 통해, 현재 온 사람이 가져갈 수 있는지 판단하였다.

> 기억해둘 것

`boolean flag = true;`를 통해서 특정상황에서 `false`로 만들어 사용하는 방법

`Arrays.sort(arr);`을 통해서 배열을 정렬하여 사용할 수 있다.

## 2805

22.07.19 풀이

N x N 크기의 2차원 배열을 입력받아 그 배열의 다이아몬드 형태로 된 공간에 존재하는 수를 더해 출력하는 문제

다이아몬드 형태이기 때문에 규칙성이 있었다.

- `mid`라는 변수를 만들어 행 길이의 절반을 저장하였다.

- `i`행이라고 할 때 시작지점의 index는 `Math.abs(i - mid)`

- 끝나는 지점의 index는 `N - Math.abs(i - mid) - 1`이다.

각 행의 시작지점과 마지막지점 사이에 존재하는 2차원 배열의 요소만 더하는 방식으로 풀이하였다.

> 어려웠던 점

입력을 받을 때, 2차원 배열을 띄어쓰기 없이 입력을 받아야했다.
- 이를 String으로 입력받아 `charAt()`메소드를 이용하여 char 형태로 입력받고
- int형으로 형변환하여 사용하였다.
- 이때, ASCII CODE로 정수를 받기 때문에 48을 빼주는 것을 통해 입력받은 정수로 계산을 하였다.

## 6190

22.07.27 풀이

N개의 정수가 주어지고, N개 중 2개의 수를 뽑아 곱한 값들 중 단조 증가하는 수의 최댓값을 구하는 문제. 여기서 단조 증가란 뒷자릿수로 갈수록 크기가 같거나 커지는 수를 말한다.

문제를 해결하기 위해 두가지 메서드를 선언하였다.

1. 입력받은 숫자가 단조 증가하는 수인지 boolean으로 판별해주는 메서드
2. 정수 배열을 입력받아 그 요소끼리의 곱 중 단조 증가하는 수의 최댓값을 구해주는 메서드

위 두가지 함수를 구현하여 풀이하였다. 

다만, 단조 증가하는 수가 없는 경우, -1 을 출력한다는 조건을 놓쳐, 한번 오답을 맛봐야했다.

## 6485

22.07.20 풀이

N개의 버스가 다니는 정류장의 범위가 각각 숫자로 주어지고 P개의 정류장에 대해 각 정류자에 몇 대의 버스가 지나가는 지 출력하는 문제

버스들과 각 버스의 시점과 종점을 2차원 배열로 입력받았다.

그리고 주어지는 버스 정류장이 각 버스의 시점과 종점 사이에 있는지 확인하고 사이에 있다면 1씩 더해 최종적으로 출력하는 방식으로 풀이 하였다.

> 또 다른 풀이

처음에는 정류장의 범위가 1~5000으로 주어져 있어 길이가 5000인 배열을 만들어 버스의 시점과 종점사이에 있는 수에 1씩 더해가며 마지막엔 해당 정류장의 숫자만 출력하는 방식으로 풀이하려 하였다.
하지만, 5000길이 배열은 너무 메모리를 많이 잡아먹어 `runtime error`가 발생하여 풀이방법을 수정하였다.
