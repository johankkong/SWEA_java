D3 문제풀이 방법입니다.

---

## 1206

22.08.08 풀이

건물의 높이가 차례대로 주어진다. 해당 건물 층별로 좌우로 2칸에 건물이 없다면, 해당 층을 조망권이 보장된 층이라고 한다. 이때, 조망권이 보장되는 층수의 총합을 출력하는 문제

건물의 높이들을 차례대로 입력받아, 배열에 저장한다. 각 건물별로 인접한 건물과의 높이 차이를 이용해, 조망권이 확보되는 층수를 계산하고 총합을 더하는 방식으로 풀이하였다. 

이 과정에서 배열과 인데스를 입력받아 해당 인덱스의 건물에 조망권이 확보되는 층수를 리턴하는 함수를 선언하여 사용하였다.

한 건물에서 조망권이 확보되는 층을 계산하는 방법은 인접한 4개의 건물 중, 가장 높은 건물과의 차이를 계산하면 된다. 만약 가장 높은 건물이 해당 건물보다 높다면, 조망권이 확보되는 층은 없다.

> 알아둘 것

`Math.max()` 와 `Math.min()`은 매개값을 두개만 받을 수 있기때문에 두개씩 연결하여 사용하였다. `Math.min(Math.min(a, b), Math.min(c, d))`

## 1220

22.07.26 풀이

100 x 100 배열에서 1은 아래로 이동하고 2는 위로 이동한다. 이 때, 1과 2가 만나면 교착상태에 빠져 그자리에 정지하게 된다. 모든 이동이 끝나고 교착상태에 있는 그룹의 갯수를 출력하는 문제

입력으로 주어지는 100 x 100을 2차원 배열로 입력받았다. 모든 요소가 위아래로만 움직이기 때문에 배열을 탐색함에 있어서 열단위로 나누어 먼저 `for`문을 사용하였다.

세로로 각 칸을 탐색하게 되는데 각 칸은 1, 2, 0의 값만을 가진다.

0인 경우, 바로 다음칸으로 넘어가면 되고

1인경우, 현재 상태를 나타내는 `tmp` 변수를 1로 만들어주고

2인경우, `tmp`변수가 1이면 교착상태가 되므로 `result` 변수에 1을 더해주고 `tmp`변수를 다시 0으로 만들어준다.

모든 열에 대한 탐색이 끝나면 `result`를 출력하는 것으로 풀이하였다.

## 1860

22.07.18 풀이

M초 마다 K개의 붕어빵을 생산한다고 할때 N명의 사람이 도착하는 시간을 입력받아 N명의 사람이 기다리는 시간없이 붕어빵을 가져갈 수 있는지 출력하는 문제

N명의 사람이 도착하는 시간이 순서대로 주어져 있지 않아, 배열로 입력받은 뒤 `Arrays.sort(arr);`을 이용하여 정렬하였다.

그리고 순차적으로 각 도착하는 시간을 M으로 나누고 K를 곱하여 현재까지 생산된 붕어빵의 갯수를 구하였다.

그리고 지금까지 다녀간 사람들의 명수를 빼는 것을 통해, 현재 온 사람이 가져갈 수 있는지 판단하였다.

> 기억해둘 것

`boolean flag = true;`를 통해서 특정상황에서 `false`로 만들어 사용하는 방법

`Arrays.sort(arr);`을 통해서 배열을 정렬하여 사용할 수 있다.

## 2805

22.07.19 풀이

N x N 크기의 2차원 배열을 입력받아 그 배열의 다이아몬드 형태로 된 공간에 존재하는 수를 더해 출력하는 문제

다이아몬드 형태이기 때문에 규칙성이 있었다.

- `mid`라는 변수를 만들어 행 길이의 절반을 저장하였다.

- `i`행이라고 할 때 시작지점의 index는 `Math.abs(i - mid)`

- 끝나는 지점의 index는 `N - Math.abs(i - mid) - 1`이다.

각 행의 시작지점과 마지막지점 사이에 존재하는 2차원 배열의 요소만 더하는 방식으로 풀이하였다.

> 어려웠던 점

입력을 받을 때, 2차원 배열을 띄어쓰기 없이 입력을 받아야했다.
- 이를 String으로 입력받아 `charAt()`메소드를 이용하여 char 형태로 입력받고
- int형으로 형변환하여 사용하였다.
- 이때, ASCII CODE로 정수를 받기 때문에 48을 빼주는 것을 통해 입력받은 정수로 계산을 하였다.

## 4789

22.07.25 풀이

문자열을 입력받는데, i 번째 문자는 i - 1 명의 사람이 박수를 칠 때 자신도 박수를 치기 시작한다고 할 때, 전원이 박수를 치게 하기 위해 몇 명을 추가해야하는지 출력하는 문제

띄어쓰기 없이 문자열이 주어졌기 때문에 String 형태로 입력받아 charAt(i) 을 통해 char 형태로 변환하고 0 의 아스키코드인 48을 빼주는 것을 통해 정수 배열로 변환할 수 있었다.

정수 배열의 요소를 하나씩 탐색하며 현재 박수를 치고 있는 인원과 다음인원이 박수를 치기 위해 필요한 인원수를 비교해가며 필요한 인원만큼 변수에 더해 가는 방식으로 풀이하였다.

## 5789

22.07.30 풀이

N개의 상자가 있고, Q번동안 상자에 숫자를 쓰게 되는데, i번째에 L번째부터 R번째까지 i 숫자를 적는다고 할 때, 모든 활동을 마친 후에 각 상자에 써있는 숫자를 출력하는 문제

N을 입력받아 길이 N의 배열을 생성하고, Q회동안 반복하여 L부터 R까지의 배열에 숫자 i를 대입하는 방식으로 풀이하였다. 

L과 R을 바로 인덱스로 활용하기 위하여 입력받으면서 1을 빼주었다.

## 6190

22.07.27 풀이

N개의 정수가 주어지고, N개 중 2개의 수를 뽑아 곱한 값들 중 단조 증가하는 수의 최댓값을 구하는 문제. 여기서 단조 증가란 뒷자릿수로 갈수록 크기가 같거나 커지는 수를 말한다.

문제를 해결하기 위해 두가지 메서드를 선언하였다.

1. 입력받은 숫자가 단조 증가하는 수인지 boolean으로 판별해주는 메서드
2. 정수 배열을 입력받아 그 요소끼리의 곱 중 단조 증가하는 수의 최댓값을 구해주는 메서드

위 두가지 함수를 구현하여 풀이하였다. 

다만, 단조 증가하는 수가 없는 경우, -1 을 출력한다는 조건을 놓쳐, 한번 오답을 맛봐야했다.

## 6485

22.07.20 풀이

N개의 버스가 다니는 정류장의 범위가 각각 숫자로 주어지고 P개의 정류장에 대해 각 정류자에 몇 대의 버스가 지나가는 지 출력하는 문제

버스들과 각 버스의 시점과 종점을 2차원 배열로 입력받았다.

그리고 주어지는 버스 정류장이 각 버스의 시점과 종점 사이에 있는지 확인하고 사이에 있다면 1씩 더해 최종적으로 출력하는 방식으로 풀이 하였다.

> 또 다른 풀이

처음에는 정류장의 범위가 1~5000으로 주어져 있어 길이가 5000인 배열을 만들어 버스의 시점과 종점사이에 있는 수에 1씩 더해가며 마지막엔 해당 정류장의 숫자만 출력하는 방식으로 풀이하려 하였다.
하지만, 5000길이 배열은 너무 메모리를 많이 잡아먹어 `runtime error`가 발생하여 풀이방법을 수정하였다.
