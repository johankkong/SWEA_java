D3 문제풀이 방법입니다.

---

## 1206

22.08.08 풀이

건물의 높이가 차례대로 주어진다. 해당 건물 층별로 좌우로 2칸에 건물이 없다면, 해당 층을 조망권이 보장된 층이라고 한다. 이때, 조망권이 보장되는 층수의 총합을 출력하는 문제

건물의 높이들을 차례대로 입력받아, 배열에 저장한다. 각 건물별로 인접한 건물과의 높이 차이를 이용해, 조망권이 확보되는 층수를 계산하고 총합을 더하는 방식으로 풀이하였다. 

이 과정에서 배열과 인데스를 입력받아 해당 인덱스의 건물에 조망권이 확보되는 층수를 리턴하는 함수를 선언하여 사용하였다.

한 건물에서 조망권이 확보되는 층을 계산하는 방법은 인접한 4개의 건물 중, 가장 높은 건물과의 차이를 계산하면 된다. 만약 가장 높은 건물이 해당 건물보다 높다면, 조망권이 확보되는 층은 없다.

> 알아둘 것

`Math.max()` 와 `Math.min()`은 매개값을 두개만 받을 수 있기때문에 두개씩 연결하여 사용하였다. `Math.min(Math.min(a, b), Math.min(c, d))`

## 1208

22.08.09 풀이

100개의 칸에 상자들이 쌓여있다. 이를 n번 동안 가장 높은 위치에서 가장 낮은 위치로 상자를 내린다고 했을 때, n번 반복한 후 최고 높이와 최저 높이의 차이를 출력하는 문제.

상자들의 높이를 List에 입력받아, sort를 진행한 후, 가장 높은 위치에서 1을 빼고 가장 낮은 위치에서 1을 더하는 방식으로 n번 반복하고 마지막에 그 차이를 출력하는 방식으로 풀이하였다.

> 알아둘 것

List를 sort할 때는 `Collections.sort(list)`를 이용한다.

List보다 Array를 활용하는 것이 나았을 것.

## 1209

22.08.10 풀이

100 x 100 크기의 2차원 배열을 입력받아, 각 행의 합, 각 열의 합, 대각선의 합을 구해 그 중 최댓값을 출력하는 문제

가장 먼저 2차원 배열은 만들어 숫자들을 입력받았다.

그리고 각 행의 합, 각 열의 합, 대각선의 합을 저장할 길이 202 짜리의 배열을 선언하였다.

인덱스 기준 0~99는 각 행의 합, 100~199는 각 열의 합, 200은 왼쪽 위 대각선의 합, 201은 오른쪽 위 대각선의 합을 저장하였다.

각 요소는 `[i][j]` 라고 할 때, [i]에 더해지고, [j+100]에 더해지고, i와 j가 같은 경우 200, i + j 가 99인 경우 201에 값이 저장되었다.

합산을 완료한 뒤, 길이 202 배열 중 최대값을 출력하는 것으로 풀이하였다.

## 1213

22.08.12 풀이

짧은 문자열과 긴 문자열을 입력받아 긴 문자열에서 짧은 문자열이 몇번 등장하는지 출력하는 문제

2중 `for`문을 통해 등장하는 횟수를 탐색하였다.

첫번째 `for`문을 통해 긴 문자열을 하나씩 탐색하였다. 이 때, 긴문자열에서 짧은 문자열의 길이를 뺀 수까지만 인덱스가 이동해야한다.

두번째 `for`문을 통해 짧은 문자열의 한글자씩 받아오며 긴문자열과 비교했다.

일치하지 않는 경우, 다음으로 넘어가는 방식으로 전부 탐색하고 최종적인 빈도를 계산하여 제출하였다.

## 1215

22.08.12 풀이

8 x 8 크기의 2차원 배열에 A, B, C 문자로만 채워져 있다고 할때, 주어진 길이의 회문이 몇개 있는지 확인하여 출력하는 문제

주어진 크기를 가로와 세로로 나누어 모두 탐색하여, 회문이 몇 개인지 출력하였다. 

회문을 검사할 때엔 charAt() 메소드를 이용하여 앞쪽 절반의 char에 대해 반대편 char와 같은지 확인하고 모두 같은 경우, +1, 중간에 하나라도 다르다면 다음 칸을 탐색하는 방식으로 진행하였다.

## 1216

22.08.12 풀이

100 x 100 크기의 2차원 배열에 A, B, C 문자로만 채워져 있다고 할때, 가장 긴 회문의 길이는 몇인지 찾아 출력하는 문제

가장 긴 회문을 찾는 문제이기 때문에, 모든 칸에 대해 가로줄 혹은 세로줄 끝부터 한칸씩 줄여가며 그 사이가 회문인지 검사하는 방식으로 풀이하였다.

가장 끝부터 역으로 길이를 줄여나가기 때문에 한 줄에서 회문이 한번 발생하였다면 그 줄에서 최대 길이의 회문이 발생한 것이므로 다음 줄로 넘어가도록 하였다.

## 1220

22.07.26 풀이

100 x 100 배열에서 1은 아래로 이동하고 2는 위로 이동한다. 이 때, 1과 2가 만나면 교착상태에 빠져 그자리에 정지하게 된다. 모든 이동이 끝나고 교착상태에 있는 그룹의 갯수를 출력하는 문제

입력으로 주어지는 100 x 100을 2차원 배열로 입력받았다. 모든 요소가 위아래로만 움직이기 때문에 배열을 탐색함에 있어서 열단위로 나누어 먼저 `for`문을 사용하였다.

세로로 각 칸을 탐색하게 되는데 각 칸은 1, 2, 0의 값만을 가진다.

0인 경우, 바로 다음칸으로 넘어가면 되고

1인경우, 현재 상태를 나타내는 `tmp` 변수를 1로 만들어주고

2인경우, `tmp`변수가 1이면 교착상태가 되므로 `result` 변수에 1을 더해주고 `tmp`변수를 다시 0으로 만들어준다.

모든 열에 대한 탐색이 끝나면 `result`를 출력하는 것으로 풀이하였다.

## 1228

22.08.19 풀이

주어진 암호문에 특정 위치에 원하는 갯수만큼 숫자를 삽입하여 가장 앞쪽 10개의 수를 출력하는 문제

LinkedList를 이용하여 숫자들을 입력받고, 그 뒤에 나오는 위치 정보와 삽입 숫자들을 입력받아 차례대로 출력하는 방식으로 구현하였다.

LinkedList를 이용한 이유는 삽입이 많이 일어나기때문에 ArrayList보다 유리할 것이라고 생각했기 때문이다.

## 1230

22.08.19 풀이

주어진 암호문에 입력되는 명령에 따라 삽입, 삭제, 추가를 하여 가장 앞쪽 10개를 출력하는 문제

BufferedReader를 통해 각 단어를 입력받았고, switch문을 이용하여 각 명령 별로 수행할 행동들을 작성하였다.

중간 삽입의 경우, `list.add(index, data)`메소드를 이용

중간 삭제의 겨우, `remove(index)` 메소드를 이용

뒤에 추가의 경우엔 `add(data)` 메소드를 이용하였다.

## 1289 - 원재의 메모리 복구하기

22.08.25 풀이

특정 위치의 비트를 0또는 1로 바꾸면 그 뒤에 모든 bit가 바뀌는 규칙을 따른다고 할 때, 0에서 시작하여 주어진 비트값을 가지려면 몇 번 수행해야하는 지 구하는 문제

왼쪽의 수행이 오른쪽 비트에 영향을 미치기 때문에, 가장 왼쪽부터 수행을 해야한다.

가장 왼쪽부터 1과 0이 바뀌는 지점의 수를 세주기만 하면 풀 수 있다.

## 1860

22.07.18 풀이

M초 마다 K개의 붕어빵을 생산한다고 할때 N명의 사람이 도착하는 시간을 입력받아 N명의 사람이 기다리는 시간없이 붕어빵을 가져갈 수 있는지 출력하는 문제

N명의 사람이 도착하는 시간이 순서대로 주어져 있지 않아, 배열로 입력받은 뒤 `Arrays.sort(arr);`을 이용하여 정렬하였다.

그리고 순차적으로 각 도착하는 시간을 M으로 나누고 K를 곱하여 현재까지 생산된 붕어빵의 갯수를 구하였다.

그리고 지금까지 다녀간 사람들의 명수를 빼는 것을 통해, 현재 온 사람이 가져갈 수 있는지 판단하였다.

> 기억해둘 것

`boolean flag = true;`를 통해서 특정상황에서 `false`로 만들어 사용하는 방법

`Arrays.sort(arr);`을 통해서 배열을 정렬하여 사용할 수 있다.

## 1873

22.08.22 풀이

탱크 게임을 문자열로 만든 문제. 주어지는 명령에 따라 탱크를 움직이고 포탄을 쏴서 벽을 파괴한 결과를 출력하는 문제

각 명령에 따른 메소드를 구현하였다. 

방향을 변경하는 과정은 switch 구문을 이용하였고, 이동 및 포탄 사격은 델타 이동을 이용하였다.

> 주요했던 부분

각 요소들이 문자열로 주어졌고, 연산과정도 문자열로 하는 과정에서 비교함에 있어 `equals()` 메소드를 사용해야했다.

## 2805

22.07.19 풀이

N x N 크기의 2차원 배열을 입력받아 그 배열의 다이아몬드 형태로 된 공간에 존재하는 수를 더해 출력하는 문제

다이아몬드 형태이기 때문에 규칙성이 있었다.

- `mid`라는 변수를 만들어 행 길이의 절반을 저장하였다.

- `i`행이라고 할 때 시작지점의 index는 `Math.abs(i - mid)`

- 끝나는 지점의 index는 `N - Math.abs(i - mid) - 1`이다.

각 행의 시작지점과 마지막지점 사이에 존재하는 2차원 배열의 요소만 더하는 방식으로 풀이하였다.

> 어려웠던 점

입력을 받을 때, 2차원 배열을 띄어쓰기 없이 입력을 받아야했다.
- 이를 String으로 입력받아 `charAt()`메소드를 이용하여 char 형태로 입력받고
- int형으로 형변환하여 사용하였다.
- 이때, ASCII CODE로 정수를 받기 때문에 48을 빼주는 것을 통해 입력받은 정수로 계산을 하였다.

## 2806 - N-Queen

22.09.21 풀이

N X N 크기의 체스판에 N개의 Queen을 서로 공격할 수 없도록 배치하는 경우의 수를 구하는 문제

각 행 별로 Queen을 놓는 재귀함수를 작성하여 풀이하였다.

이 과정에서 해당 칸이 Queen을 놓을 수 있는 자리인지 판단하는 메소드를 작성하여, 다음 재귀를 호출하기 이전에 판별해주었다.

## 2817 - 부분 수열의 합

22.08.24 풀이

N개의 수를 가지는 수열과 함께 K가 주어지는데, 부분 수열의 합 중에서 K가 되는 경우의 수가 몇 개가 있는 지 구하는 문제

부분집합 개념으로 재귀함수를 이용하여 풀이하였다.

N크기의 boolean 배열을 만들어 각 요소가 선택되었는 지 확인였다.

재귀함수를 이용하여, 각 요소들이 선택되고 선택되지 않은 모든 경우의 수를 탐색하여 풀이하였다.

## 2930 - 힙

22.08.23 풀이

힙을 구현하여 1이라는 명령어는 함께 들어오는 숫자를 heap에 추가하고, 2라는 명령어는 heap에서 최대값을 제거하여 출력하는 문제

완전 이진 탐색인 heap의 성질을 이용하여 배열로 위 기능들을 구현하였다.

heap에서 가장 마지막 인덱스를 추적하는 end변수를 사용하였고, 이 end변수를 이용하여 해당 인덱스에 수를 추가하였다.

값을 추가한 이후에는 해당 칸보다 윗 칸, 즉 인덱스 기준 1/2 인덱스의 칸이 자신보다 커질 때까지 교환해 올라갔다.

값을 제거하는 경우, 1 인덱스의 값을 출력하고 end 인덱스의 값을 1에 넣었다. 그 이후, 자신보다 큰 자식 노드와 바꿔나가며 힙을 재정렬 하였다.

## 3499

22.08.19 풀이

N개의 카드와 카드에 적힌 문자열이 순서대로 주어진다고 할 때, 그 카드 더미를 반으로 나누어 하나씩 내려놓는 퍼펙트 셔플을 하고난 뒤의 카드의 순서대로 문자열을 출력하는 문제

처음 입력받는 문자열들을 순서대로 문자열 배열에 저장하였다.

그리고, 절반까지의 문자열들을 하나의 Queue에, 그리고 나머지 절반은 다른 Queue에 순서대로 집어넣었다.

그 뒤, 각 Queue에서 하나씩 빼며 결과를 출력하였다.

이 때, 카드 전체의 갯수가 짝수일 경우, 왼쪽 카드 더미의 카드 수가 1씩 달라지는 것에 주의하자!

## 4789

22.07.25 풀이

문자열을 입력받는데, i 번째 문자는 i - 1 명의 사람이 박수를 칠 때 자신도 박수를 치기 시작한다고 할 때, 전원이 박수를 치게 하기 위해 몇 명을 추가해야하는지 출력하는 문제

띄어쓰기 없이 문자열이 주어졌기 때문에 String 형태로 입력받아 charAt(i) 을 통해 char 형태로 변환하고 0 의 아스키코드인 48을 빼주는 것을 통해 정수 배열로 변환할 수 있었다.

정수 배열의 요소를 하나씩 탐색하며 현재 박수를 치고 있는 인원과 다음인원이 박수를 치기 위해 필요한 인원수를 비교해가며 필요한 인원만큼 변수에 더해 가는 방식으로 풀이하였다.

## 5215

22.08.24 풀이

N개의 음식에 대한 가치와 칼로리가 주어지고 제한 칼로리가 주어진다. 제한 칼로리를 넘기지 않고 얻을 수 있는 최대한의 가치를 구하는 문제

부분집합을 이용하여 풀이하였다.

방문한 요소를 표시하는 boolean집합과 재귀함수를 이용하여 모든 부분 집합을 만들어가며 가장 높은 가치를 저장하고 출력하는 방식으로 풀이하였다.

## 5789

22.07.30 풀이

N개의 상자가 있고, Q번동안 상자에 숫자를 쓰게 되는데, i번째에 L번째부터 R번째까지 i 숫자를 적는다고 할 때, 모든 활동을 마친 후에 각 상자에 써있는 숫자를 출력하는 문제

N을 입력받아 길이 N의 배열을 생성하고, Q회동안 반복하여 L부터 R까지의 배열에 숫자 i를 대입하는 방식으로 풀이하였다. 

L과 R을 바로 인덱스로 활용하기 위하여 입력받으면서 1을 빼주었다.

## 6190

22.07.27 풀이

N개의 정수가 주어지고, N개 중 2개의 수를 뽑아 곱한 값들 중 단조 증가하는 수의 최댓값을 구하는 문제. 여기서 단조 증가란 뒷자릿수로 갈수록 크기가 같거나 커지는 수를 말한다.

문제를 해결하기 위해 두가지 메서드를 선언하였다.

1. 입력받은 숫자가 단조 증가하는 수인지 boolean으로 판별해주는 메서드
2. 정수 배열을 입력받아 그 요소끼리의 곱 중 단조 증가하는 수의 최댓값을 구해주는 메서드

위 두가지 함수를 구현하여 풀이하였다. 

다만, 단조 증가하는 수가 없는 경우, -1 을 출력한다는 조건을 놓쳐, 한번 오답을 맛봐야했다.

## 6485

22.07.20 풀이

N개의 버스가 다니는 정류장의 범위가 각각 숫자로 주어지고 P개의 정류장에 대해 각 정류자에 몇 대의 버스가 지나가는 지 출력하는 문제

버스들과 각 버스의 시점과 종점을 2차원 배열로 입력받았다.

그리고 주어지는 버스 정류장이 각 버스의 시점과 종점 사이에 있는지 확인하고 사이에 있다면 1씩 더해 최종적으로 출력하는 방식으로 풀이 하였다.

> 또 다른 풀이

처음에는 정류장의 범위가 1~5000으로 주어져 있어 길이가 5000인 배열을 만들어 버스의 시점과 종점사이에 있는 수에 1씩 더해가며 마지막엔 해당 정류장의 숫자만 출력하는 방식으로 풀이하려 하였다.
하지만, 5000길이 배열은 너무 메모리를 많이 잡아먹어 `runtime error`가 발생하여 풀이방법을 수정하였다.

## 11315 - 오목판정

주어진 오목 게임판에서 오목이 발생했는지 판단하는 문제

"o"가 있는 위치에서 우상, 우, 우하, 하 방향으로 5개가 "o"가 맞는지 판단하는 메소드를 만들어 판단하였다.

판단하는 과정에서 경계선 밖으로 나가거나 "o"가 아닌 경우 바로 false를 return하도록 하였다.
